# project-Orwell-gopher
go implementation of project orwell

## context

Project Orwell is a society simulator.

Born out of a combination of Field simulation with point objects referencing matrices of arbitrary precision.

This allows us to represent 'entities' as objects / classes, with persistent properties and locations.

It also allows us to represent the 'fabric' of a society in the form of fields, which are themselves represented as matrices.

While somewhat computationally heavy, this method allows us to generate a truly dynamic world based on randomised initial conditions.

The intention is for this to be able to function as an outline story generator.

By setting the evolution of the system as realistic, it becomes possible for authorial contrivances in the protagonists journey to have realistic consequences, and create a rich backstory which slowly reduces the need for those contrivances at all.

This version of the simulator is written in Go, as an attempt to optimise and refine the aforementioned computational intensity.

### Details of Field Mapping

A full resolution mapping of a space-time-esque field would be extremely computationally intensive. Instead this process relies on the fact that rounded approximations will generate effects which are somewhat relatable to expected physical behaviour.

If there is a number of object which generate a self influencing attractive field. We would expect them to move towards each other. 

If some of those objects generate a repulsive field in another layer, we would expect them to form a sort of equilibrium state, where that repulsive force is balanced by the attractive one. 

In small enough systems we would expect some kind of globally stable system to arise, but with enough participants, analogues to chaos theory would dicatate that the system will be constantly evolving. 

This symptom, of a constantly evolving, but physically plausible state based on declared properties, is exactly what we are looking for. 

Since we don't care about detailed field mapping, instead of needing to calculate detail differentials of all points in space in a field, we can instead pre-calculate the force gradient in a grid. 

This grid will represent a rounding effect, which will get less and less precise as the gradients get more extreme, and a simple 2 dimensional grid starts to map less and less evenly to the represented field space.

#### Example

A field G (resembling gravity) is generated by, and acts on, the magnitude value of an entity M. 

This is represented by a Field object, and several Entity objects with magnitude M

Each entity has a generation call, which interacts with the field object to iterate it with the field effect of their current position. The Entity does not know the decay pattern of its current field influence, just its location and magnitude, and it's former location and magnitude.

The entity calls the field with an old and current location. The Field object calculates the field changes to represent any change of state in the entity.

Each entity also has an action call. which interacts with the field object, this time only supplying current location and magnitude. The field then returns an acceleration. The sum of all field accelerations in an action call is evaluated to change the velocity, and the velocity is evaluated to change the location.


